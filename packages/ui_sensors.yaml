# Home Assistant Sensoren

sensor:
  # Außentemperatur ohne Farbwechsel
  - platform: homeassistant
    id: temp_aussen_sensor
    entity_id: sensor.thermometer_aussen_temperature
    on_value:
      - lvgl.label.update:
          id: temp_aussen
          text: !lambda |-
            static char buf[10];
            snprintf(buf, sizeof(buf), "%.1f°C", x);
            return buf;

  # Stromverbrauchssensor für alternative Anzeige
  - platform: homeassistant
    id: power_consumption_sensor
    entity_id: sensor.tibber_watt_korrigiert
    on_value:
      - lvgl.label.update:
          id: alt_clock_label
          text: !lambda |-
            static char buf[10];
            snprintf(buf, sizeof(buf), "%.0f W", x);
            return buf;

  # Wohnzimmer-Temperatur
  - platform: homeassistant
    id: temp_wohnzimmer_sensor
    entity_id: sensor.thermometer_wohnzimmer_temperature
    on_value:
      - lvgl.label.update:
          id: temp_wohnzimmer
          text: !lambda |-
            static char buf[10];
            snprintf(buf, sizeof(buf), "%.1f°C", x);
            return buf;

text_sensor:
  - platform: homeassistant
    id: weather_state
    entity_id: weather.leipzig_holzhausen
    on_value:
      - lambda: |-
          std::string state = x;
          if (state == "sunny") lv_img_set_src(id(weather_condition), id(weather_sunny));
          else if (state == "cloudy") lv_img_set_src(id(weather_condition), id(weather_cloudy));
          else if (state == "partlycloudy") lv_img_set_src(id(weather_condition), id(weather_partlycloudy));
          else if (state == "rainy") lv_img_set_src(id(weather_condition), id(weather_rainy));
          else if (state == "pouring") lv_img_set_src(id(weather_condition), id(weather_pouring));
          else if (state == "snowy") lv_img_set_src(id(weather_condition), id(weather_snowy));
          else if (state == "snowy-rainy") lv_img_set_src(id(weather_condition), id(weather_snowy_rainy));
          else if (state == "fog") lv_img_set_src(id(weather_condition), id(weather_fog));
          else if (state == "clear-night") lv_img_set_src(id(weather_condition), id(weather_clear_night));
          else if (state == "hail") lv_img_set_src(id(weather_condition), id(weather_hail));
          else if (state == "lightning") lv_img_set_src(id(weather_condition), id(weather_lightning));
          else if (state == "lightning-rainy") lv_img_set_src(id(weather_condition), id(weather_lightning_rainy));
          else if (state == "windy") lv_img_set_src(id(weather_condition), id(weather_windy));
          else if (state == "windy-variant") lv_img_set_src(id(weather_condition), id(weather_windy_variant));
          else lv_img_set_src(id(weather_condition), id(weather_default));

  - platform: homeassistant
    id: washer_status_sensor
    entity_id: sensor.waschtrockner_betriebszustand
    internal: true
    on_value: &update_display
      - lvgl.label.update:
          id: washer_time
          text: !lambda |-
            std::string status = id(washer_status_sensor).state; 
            std::string time_str = id(washer_time_sensor).state;
            
            // 1. Einfache Status-Sachen
            if (status == "inactive" || status == "ready") return "Bereit";
            if (status == "finished") return "Fertig";
            if (status == "pause") return "Pause";
            if (status == "error" || status == "aborting") return "Prüfen!";

            if (status == "run" || status == "delayedstart") {
              if (time_str.length() >= 19) {
                int Y, M, D, h, m, s;
                if (sscanf(time_str.c_str(), "%d-%d-%dT%d:%d:%d", &Y, &M, &D, &h, &m, &s) == 6) {
                    int a1 = (14 - M) / 12;
                    int y1 = Y + 4800 - a1;
                    int m1 = M + 12 * a1 - 3;
                    int jdn_target = D + (153 * m1 + 2) / 5 + 365 * y1 + y1 / 4 - y1 / 100 + y1 / 400 - 32045;
                    
                    auto now_utc = id(esptime).utcnow();
                    int a2 = (14 - now_utc.month) / 12;
                    int y2 = now_utc.year + 4800 - a2;
                    int m2 = now_utc.month + 12 * a2 - 3;
                    int jdn_now = now_utc.day_of_month + (153 * m2 + 2) / 5 + 365 * y2 + y2 / 4 - y2 / 100 + y2 / 400 - 32045;

                    long diff_days = jdn_target - jdn_now;
                    long target_sec_day = h * 3600 + m * 60 + s;
                    long now_sec_day = now_utc.hour * 3600 + now_utc.minute * 60 + now_utc.second;
                    long total_diff = (diff_days * 86400) + (target_sec_day - now_sec_day);

                    if (total_diff > 0 && total_diff < 604800) {
                      auto now_local = id(esptime).now();
                      long local_start_seconds = now_local.hour * 3600 + now_local.minute * 60 + now_local.second;
                      long local_end_seconds = local_start_seconds + total_diff;
                      
                      int end_h = (local_end_seconds / 3600) % 24;
                      int end_m = (local_end_seconds % 3600) / 60;

                      char buf[16];
                      snprintf(buf, sizeof(buf), "%d:%02d", end_h, end_m);
                      
                      if (status == "delayedstart") return std::string("-> ") + buf;
                      return std::string(buf);
                    } else {
                      return "Gleich...";
                    }
                } else {
                  ESP_LOGE("time_parse", "Failed to parse time string: %s", time_str.c_str());
                  return "Zeitfehler";
                }
              }
              return "Läuft";
            }

            return status;

  - platform: homeassistant
    id: washer_time_sensor
    entity_id: sensor.waschtrockner_programm_endzeit
    internal: true
    on_value: *update_display

  - platform: homeassistant
    id: timer_timer_state
    entity_id: timer.waveshare_display
    internal: true
    on_value:
      - lambda: |-
          std::string status = x;
          if (status == "active") {
             id(timer_timer_active) = true;
          } else {
             id(timer_timer_active) = false;
             if (status == "idle") {
               id(timer_remaining_seconds) = 0;
             }
          }
      # Umschaltung der Anzeige-Elemente bei Timer-Statusänderung
      - lambda: |-
          // Timer-Elemente ein/ausblenden basierend auf Timer-Status
          if (id(timer_timer_active)) {
            // Timer läuft: Timer-Elemente anzeigen, alternative Elemente ausblenden
            lv_obj_add_flag(id(alt_clock_icon), LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(id(alt_clock_label), LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(id(timer_icon), LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(id(timer_timer_label), LV_OBJ_FLAG_HIDDEN);
          } else {
            // Timer läuft nicht: Alternative Elemente anzeigen, Timer-Elemente ausblenden
            lv_obj_add_flag(id(timer_icon), LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(id(timer_timer_label), LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(id(alt_clock_icon), LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(id(alt_clock_label), LV_OBJ_FLAG_HIDDEN);
          }

  - platform: homeassistant
    id: timer_timer_remaining
    entity_id: timer.waveshare_display
    attribute: remaining
    internal: true
    on_value:
      - lambda: |-
          std::string time_str = x;
          if (time_str.empty() || time_str == "None" || time_str == "unavailable") return;

          int hours = 0, mins = 0, secs = 0;
          if (sscanf(time_str.c_str(), "%d:%d:%d", &hours, &mins, &secs) == 3) {
            id(timer_remaining_seconds) = hours * 3600 + mins * 60 + secs;
          }
          else if (sscanf(time_str.c_str(), "%d:%d", &hours, &mins) == 2) {
            id(timer_remaining_seconds) = hours * 3600 + mins * 60;
          }
          else if (sscanf(time_str.c_str(), "%d:%d", &mins, &secs) == 2) {
            id(timer_remaining_seconds) = mins * 60 + secs;
          }
      # Umschaltung der Anzeige-Elemente bei Timer-Start
      - lambda: |-
          // Wenn Timer aktiv ist und verbleibende Zeit > 0, Timer-Elemente anzeigen
          if (id(timer_timer_active) && id(timer_remaining_seconds) > 0) {
            lv_obj_add_flag(id(alt_clock_icon), LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(id(alt_clock_label), LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(id(timer_icon), LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(id(timer_timer_label), LV_OBJ_FLAG_HIDDEN);
          }
